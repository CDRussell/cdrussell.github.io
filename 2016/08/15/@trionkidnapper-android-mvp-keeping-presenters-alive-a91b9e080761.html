<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Android MVP: Keeping Presenters Alive | craigrussell</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Android MVP: Keeping Presenters Alive" />
<meta name="author" content="Craig Russell" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This article outlines a solution for allowing Presenters to survive a View’s configuration change in an MVP architecture." />
<meta property="og:description" content="This article outlines a solution for allowing Presenters to survive a View’s configuration change in an MVP architecture." />
<link rel="canonical" href="https://cdrussell.github.io//2016/08/15/@trionkidnapper-android-mvp-keeping-presenters-alive-a91b9e080761" />
<meta property="og:url" content="https://cdrussell.github.io//2016/08/15/@trionkidnapper-android-mvp-keeping-presenters-alive-a91b9e080761" />
<meta property="og:site_name" content="craigrussell" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-08-15T00:02:31+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Android MVP: Keeping Presenters Alive" />
<script type="application/ld+json">
{"description":"This article outlines a solution for allowing Presenters to survive a View’s configuration change in an MVP architecture.","url":"https://cdrussell.github.io//2016/08/15/@trionkidnapper-android-mvp-keeping-presenters-alive-a91b9e080761","@type":"BlogPosting","headline":"Android MVP: Keeping Presenters Alive","dateModified":"2016-08-15T00:02:31+00:00","datePublished":"2016-08-15T00:02:31+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://cdrussell.github.io//2016/08/15/@trionkidnapper-android-mvp-keeping-presenters-alive-a91b9e080761"},"author":{"@type":"Person","name":"Craig Russell"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <div class="wrapper">
      <header >
        <a href='https://cdrussell.github.io//'>
          <h1>craigrussell</h1>
          
            <p>Technical blog from Craig Russell.</p>
          
        </a>

        <nav>
  <div style="
         top: 0px;
         right: 0px;
         position: absolute">

    <a href="/about">
      <figure>
        <img src="/images/me-round.png"
             style="
              height: 50px;
              display: block;
              margin-left: auto;
              margin-right: auto;
              "
             alt="Photo of me, wearing a bright yellow t-shirt with a bright blue, cloudy sky in the background"
        />
        <figcaption style="text-align:justify" >About me</figcaption>
      </figure>
    </a>
  </div>
</nav>


        <p> </p>
      </header>
      <section>

      <p><em>This article outlines a solution for allowing Presenters to survive a View’s configuration change in an MVP architecture</em></p>

<h1 id="allowing-a-presenter-to-survive-activity-configuration-changes">Allowing a Presenter to Survive Activity configuration changes</h1>

<p><img src="/images/mvp-surviving-presenters-turn-to-clear.jpeg" alt="" width="100%" style="display: block; margin-left: auto; margin-right: auto;" /></p>

<h2 id="im-in-a-hurry--show-me">I’m in a Hurry — Show Me:</h2>

<h3 id="the-solution">The Solution</h3>

<p><code class="language-plaintext highlighter-rouge">onRetainCustomNonConfigurationInstance()</code> <br />
<code class="language-plaintext highlighter-rouge">getLastCustomNonConfigurationInstance()</code></p>

<p>Use these methods to store, and later retrieve, any object you want to survive an Activity’s configuration change; perfect for a Presenter in an app using an MVP architecture.</p>

<h3 id="the-source-code">The Source Code</h3>

<p>The source code for a sample project showing this in action is available on GitHub: <a href="https://github.com/CDRussell/SurvivingPresenters">https://github.com/CDRussell/SurvivingPresenters</a></p>

<p>You’ll find a full explanation of the source below.</p>

<h1 id="about-mvp">About MVP</h1>

<p>The Model View Presenter (MVP) design pattern dictates that you separate your presentation (the View) from the business logic and the data sources (the Presenter and the Model). Translated into Android terminology, this means having no logic in your Activity and making these as lightweight as possible. The Activity remains passive and is instructed on what to do and when to do it by the Presenter; also known as a Passive View design.</p>

<p>Android views, however, are complicated and have lifecycles that need carefully managed. We know that in Android if your Views are Activities then these will be destroyed and rebuilt on configuration changes (like when the user rotates the device).</p>

<p>If you have a long running operation which is a concern of your Presenter and Model, like posting data to a server or saving data into a DB, how do you keep that executing whilst your View is being destroyed and rebuilt?</p>

<h2 id="best-practice">Best Practice</h2>

<p>If you’ve been reading up on MVP, you might have noticed that there are many opinions on how it should be implemented. There is no absolute right or wrong here, and whilst that provides enough flexibility to find something right for your project, it can be daunting not to have a <em>best practice</em> implementation to use as a reference.</p>

<p>I therefore present to you, if I may be so bold, a <em>best practice</em> for allowing the Presenter to outlive the View. We don’t just want the Presenter to live forever though. We want the Presenter to survive configuration changes whilst the view is being destroyed and rebuilt. But we also want the Presenter itself to be destroyed when the user has no more need of that View.</p>

<p>In other words, if the user rotates their device, we want the Presenter to stick around. But if the user presses the back button and the Activity is destroyed <em>for good</em>, we want the Presenter to be destroyed here too.</p>

<h2 id="isnt-there-a-library-for--that">Isn’t There a Library For  That?</h2>

<p>Libraries and frameworks have been created to solve this solution. If you are interested in using one, you can check out <a href="https://github.com/konmik/nucleus">Nucleus</a> or <a href="https://github.com/sockeqwe/mosby">Mosby</a>. However, my reservation with libraries/frameworks like these is that you must place a lot of faith in them to use them. Not only do you have to trust they play nice with a typical Android project setup today, you must trust that those developers will keep the project compatible tomorrow, and the next day. In other words, it is 3rd party magic that is crucial to the project. You might be ok with that.</p>

<p>When the use of a library will be pervasive throughout my project (every Activity will depend on it) I don’t want there to be magic involved. I want to know how to solve the problem myself in case the magician were ever to… disappear. At some point along the journey to understanding 3rd party libraries, you have enough knowledge to solve the problem yourself and keep it simple in doing so.</p>

<h2 id="the-solution-1">The Solution</h2>

<p>The solution lies in the combination of two simple methods:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Object</span> <span class="nf">onRetainCustomNonConfigurationInstance</span><span class="o">()</span>  
<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getLastCustomNonConfigurationInstance</span> <span class="o">()</span>
</code></pre></div></div>

<p><a href="https://developer.android.com/reference/android/support/v4/app/FragmentActivity.html#onRetainCustomNonConfigurationInstance%28%29">onRetainCustomNonConfigurationInstance</a>(), defined in <a href="https://developer.android.com/reference/android/support/v4/app/FragmentActivity.html">FragmentActivity</a>, is provided as part of <a href="https://developer.android.com/topic/libraries/support-library/index.html">Android Support Library</a>. New apps created in recent versions of Android Studio default to using AppCompatActivity as a subclass for all your defined Activities. AppCompatActivity in turn inherits from <a href="https://developer.android.com/reference/android/support/v4/app/FragmentActivity.html">FragmentActivity</a>.</p>

<p>In other words, chances are high that you already have access to this method.</p>

<h3 id="saving-an--object">Saving an  Object</h3>

<p>The purpose of <a href="https://developer.android.com/reference/android/support/v4/app/FragmentActivity.html#onRetainCustomNonConfigurationInstance%28%29">onRetainCustomNonConfigurationInstance()</a> is to allow your Activity the ability to return a single object which can be re-used across configuration changes. This object will not serialised and deserialised, nor will it be destroyed and recreated; this object will <em>survive</em> the configuration change altogether. The exact same instance of the object that was used by the old View can be re-attached to the new View.</p>

<p>This is the perfect mechanism for storing our Presenter in MVP; when a View (Activity) is being destroyed due to a configuration change, we can return the Presenter instance from the <a href="https://developer.android.com/reference/android/support/v4/app/FragmentActivity.html#onRetainCustomNonConfigurationInstance%28%29">onRetainCustomNonConfigurationInstance()</a> method and when the new View has been recreated, we can re-attach the Presenter.</p>

<h3 id="retrieving-a-saved-object">Retrieving a Saved Object</h3>

<p>To retrieve the object stored by <a href="https://developer.android.com/reference/android/support/v4/app/FragmentActivity.html#onRetainCustomNonConfigurationInstance%28%29">onRetainCustomNonConfigurationInstance</a>() we use its opposite</p>

<p><code class="language-plaintext highlighter-rouge">getLastCustomNonConfigurationInstance();</code></p>

<p><a href="https://developer.android.com/reference/android/support/v4/app/FragmentActivity.html#getLastCustomNonConfigurationInstance%28%29">getLastCustomNonConfigurationInstance()</a> returns the value stored using <a href="https://developer.android.com/reference/android/support/v4/app/FragmentActivity.html#onRetainCustomNonConfigurationInstance%28%29">onRetainCustomNonConfigurationInstance</a>(), or null if nothing was stored.</p>

<p>As such, to meaningfully use the value returned from this method, we need to check to ensure it isn’t null and cast it to the right type of object; you’ll know the type you need to use as it has to match the object saved from <a href="https://developer.android.com/reference/android/support/v4/app/FragmentActivity.html#onRetainCustomNonConfigurationInstance%28%29">onRetainCustomNonConfigurationInstance</a>().</p>

<h3 id="sample-code">Sample Code</h3>

<p>The sample project is available on GitHub: <a href="https://github.com/CDRussell/SurvivingPresenters">https://github.com/CDRussell/SurvivingPresenters</a></p>

<p>In this sample, we have a simple Activity which contains two buttons, one to increment a counter and one to decrement the counter. We have a TextView which is used to display the current count.</p>

<p><img src="/images/mvp-surviving-presenters-activity-view.png" alt="activity view showing a number labeled counter, and buttons to increment and decrements" width="500" style="display: block; margin-left: auto; margin-right: auto;" />
We use the MVP pattern to separate concerns. The Presenter is in charge of holding the current count and changing its value and is able to instruct the view to show the user a new value. The View is in charge of responding to a user clicking on either the increment or decrement button and informing the Presenter about it.</p>

<p>We use Paul Blundell’s excellent suggested structure of the required MVP classes (<a href="https://www.novoda.com/blog/better-class-naming/">https://www.novoda.com/blog/better-class-naming/</a>) to define an interface as follows:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">interface</span> <span class="nc">IntroMvp</span> <span class="o">{</span>  
  
    <span class="kd">interface</span> <span class="nc">View</span> <span class="o">{</span>  
  
        <span class="kt">void</span> <span class="nf">updateCount</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">);</span>  
    <span class="o">}</span>  
  
    <span class="kd">interface</span> <span class="nc">Presenter</span> <span class="o">{</span>  
  
        <span class="kt">void</span> <span class="nf">attachView</span><span class="o">(</span><span class="nc">View</span> <span class="n">view</span><span class="o">);</span>  
  
        <span class="kt">void</span> <span class="nf">detachView</span><span class="o">();</span>  
  
        <span class="kt">void</span> <span class="nf">incrementValue</span><span class="o">();</span>  
  
        <span class="kt">void</span> <span class="nf">decrementValue</span><span class="o">();</span>  
    <span class="o">}</span>  
<span class="o">}</span>

</code></pre></div></div>

<p>Note, the Model is omitted here for brevity.</p>

<p>Our Activity must implement our IntroMvp.View interface and extend from AppCompatActivity</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntroActivity</span> <span class="kd">extends</span> <span class="nc">AppCompatActivity</span> <span class="kd">implements</span> <span class="nc">IntroMvp</span><span class="o">.</span><span class="na">View</span>
</code></pre></div></div>

<p>The Activity holds a reference to an instance of the IntroMvp.Presenter which it attaches to in the onCreate() method.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">IntroMvp</span><span class="o">.</span><span class="na">Presenter</span> <span class="n">presenter</span><span class="o">;</span>

<span class="nd">@Override</span>  
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="nc">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>  
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>  
    <span class="n">setContentView</span><span class="o">(</span><span class="no">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">_activity</span><span class="err">\</span><span class="n">_intro_</span><span class="o">);</span>  
    <span class="n">attachPresenter</span><span class="o">();</span>  
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">attachPresenter</span><span class="o">()</span> <span class="o">{</span>  
    <span class="n">presenter</span> <span class="o">=</span> <span class="o">(</span><span class="nc">IntroMvp</span><span class="o">.</span><span class="na">Presenter</span><span class="o">)</span> <span class="n">getLastCustomNonConfigurationInstance</span><span class="o">();</span>  
    <span class="k">if</span> <span class="o">(</span><span class="n">presenter</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>  
        <span class="n">presenter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntroPresenter</span><span class="o">();</span>  
    <span class="o">}</span>  
    <span class="n">presenter</span><span class="o">.</span><span class="na">attachView</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>  
<span class="o">}</span>
</code></pre></div></div>

<p>We retrieve an instance from the getLastCustomNonConfigurationInstance() method if it exists. If it doesn’t exist, we need to create an instance of the Presenter.</p>

<p>Finally we call presenter.attachView passing <em>this</em> which allows the Presenter to gain access to the newly created View.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">@Override</span>  
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onDestroy</span><span class="o">()</span> <span class="o">{</span>  
    <span class="n">presenter</span><span class="o">.</span><span class="na">detachView</span><span class="o">();</span>  
    <span class="kd">super</span><span class="o">.</span><span class="na">onDestroy</span><span class="o">();</span>  
<span class="o">}</span>  
  
<span class="nd">@Override</span>  
<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">onRetainCustomNonConfigurationInstance</span><span class="o">()</span> <span class="o">{</span>  
    <span class="k">return</span> <span class="n">presenter</span><span class="o">;</span>  
<span class="o">}</span>

</code></pre></div></div>

<p>The system will automatically invoke <code class="language-plaintext highlighter-rouge">onRetainCustomNonConfigurationInstance()</code> at the correct time and ask you which object you want to survive the current configuration change. You simply need to return the reference to the Presenter.</p>

<p>When the View is being destroyed, we inform the Presenter so that it doesn’t try to update an invalid View.</p>

<p>The rest of the Activity is simply handling the user pressing buttons and updating the view when told to by the Presenter.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">incrementButtonPressed</span><span class="o">(</span><span class="nc">View</span> <span class="n">view</span><span class="o">)</span> <span class="o">{</span>  
    <span class="n">presenter</span><span class="o">.</span><span class="na">incrementValue</span><span class="o">();</span>  
<span class="o">}</span>  
  
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">decrementButtonPressed</span><span class="o">(</span><span class="nc">View</span> <span class="n">view</span><span class="o">)</span> <span class="o">{</span>  
    <span class="n">presenter</span><span class="o">.</span><span class="na">decrementValue</span><span class="o">();</span>  
<span class="o">}</span>  
  
<span class="nd">@Override</span>  
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateCount</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>  
    <span class="n">runOnUiThread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>  
        <span class="nd">@Override</span>  
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>  
            <span class="n">output</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="n">getString</span><span class="o">(</span><span class="no">R</span><span class="o">.</span><span class="na">string</span><span class="o">.</span><span class="na">_updated</span><span class="err">\</span><span class="n">_count_</span><span class="o">,</span> <span class="n">count</span><span class="o">));</span>  
        <span class="o">}</span>  
    <span class="o">});</span>  
<span class="o">}</span>
</code></pre></div></div>

<p>Running the sample app, you can see that the Presenter continues to exist and hold the current value of the counter, even after the device is rotated. Additionally, if you hit the back button to properly destroy the Activity and relaunch it, the Presenter’s count will be reset to 0 as we’re dealing with a brand new instance of it in this scenario.</p>

<h3 id="summary">Summary</h3>

<p>There are a large number of words in this article, but they all lead to one simple point. Use</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">onRetainCustomNonConfigurationInstance</span><span class="o">()</span>   
<span class="n">getLastCustomNonConfigurationInstance</span><span class="o">()</span>
</code></pre></div></div>

<p>to store, and later retrieve, any object you want to survive an Activity’s configuration change; perfect for a Presenter in an app using an MVP architecture.</p>


<a href='https://cdrussell.github.io//'>Home</a>


      </section>
    </div>
    <footer>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
  </body>
</html>
